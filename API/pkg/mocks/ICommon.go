// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
	config "hospitalApi/cmd/config"
	errs "hospitalApi/pkg/errs"

	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"
)

// ICommon is an autogenerated mock type for the ICommon type
type ICommon struct {
	mock.Mock
}

// APIResponse provides a mock function with given fields: w, statusCode, data
func (_m *ICommon) APIResponse(w *gin.ResponseWriter, statusCode int, data interface{}) {
	_m.Called(w, statusCode, data)
}

// GenerateToken provides a mock function with given fields: username, jwtSecret
func (_m *ICommon) GenerateToken(username string, jwtSecret string) (string, error) {
	ret := _m.Called(username, jwtSecret)

	if len(ret) == 0 {
		panic("no return value specified for GenerateToken")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(username, jwtSecret)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(username, jwtSecret)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(username, jwtSecret)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguration provides a mock function with given fields:
func (_m *ICommon) GetConfiguration() config.Configuration {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguration")
	}

	var r0 config.Configuration
	if rf, ok := ret.Get(0).(func() config.Configuration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(config.Configuration)
	}

	return r0
}

// GetResponse provides a mock function with given fields: url
func (_m *ICommon) GetResponse(url string) ([]byte, error) {
	ret := _m.Called(url)

	if len(ret) == 0 {
		panic("no return value specified for GetResponse")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(url)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(url)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(url)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleErr provides a mock function with given fields: w, err
func (_m *ICommon) HandleErr(w *gin.ResponseWriter, err *errs.Error) errs.Error {
	ret := _m.Called(w, err)

	if len(ret) == 0 {
		panic("no return value specified for HandleErr")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(*gin.ResponseWriter, *errs.Error) errs.Error); ok {
		r0 = rf(w, err)
	} else {
		r0 = ret.Get(0).(errs.Error)
	}

	return r0
}

// HandlePanic provides a mock function with given fields: r, w
func (_m *ICommon) HandlePanic(r interface{}, w *gin.ResponseWriter) error {
	ret := _m.Called(r, w)

	if len(ret) == 0 {
		panic("no return value specified for HandlePanic")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, *gin.ResponseWriter) error); ok {
		r0 = rf(r, w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashPassword provides a mock function with given fields: plainTextPassword
func (_m *ICommon) HashPassword(plainTextPassword string) (string, error) {
	ret := _m.Called(plainTextPassword)

	if len(ret) == 0 {
		panic("no return value specified for HashPassword")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(plainTextPassword)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(plainTextPassword)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(plainTextPassword)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBoolean provides a mock function with given fields: input
func (_m *ICommon) NewBoolean(input bool) *bool {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for NewBoolean")
	}

	var r0 *bool
	if rf, ok := ret.Get(0).(func(bool) *bool); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bool)
		}
	}

	return r0
}

// NewFloat64 provides a mock function with given fields: input
func (_m *ICommon) NewFloat64(input float64) *float64 {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for NewFloat64")
	}

	var r0 *float64
	if rf, ok := ret.Get(0).(func(float64) *float64); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*float64)
		}
	}

	return r0
}

// NewInt provides a mock function with given fields: input
func (_m *ICommon) NewInt(input int) *int {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for NewInt")
	}

	var r0 *int
	if rf, ok := ret.Get(0).(func(int) *int); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*int)
		}
	}

	return r0
}

// NewString provides a mock function with given fields: input
func (_m *ICommon) NewString(input string) *string {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for NewString")
	}

	var r0 *string
	if rf, ok := ret.Get(0).(func(string) *string); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	return r0
}

// NewUInt provides a mock function with given fields: input
func (_m *ICommon) NewUInt(input uint) *uint {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for NewUInt")
	}

	var r0 *uint
	if rf, ok := ret.Get(0).(func(uint) *uint); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint)
		}
	}

	return r0
}

// ValidPassword provides a mock function with given fields: plainTextPassword
func (_m *ICommon) ValidPassword(plainTextPassword string) bool {
	ret := _m.Called(plainTextPassword)

	if len(ret) == 0 {
		panic("no return value specified for ValidPassword")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(plainTextPassword)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// NewICommon creates a new instance of ICommon. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewICommon(t interface {
	mock.TestingT
	Cleanup(func())
}) *ICommon {
	mock := &ICommon{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
